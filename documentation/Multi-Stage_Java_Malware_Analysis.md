# Multi‑Stage Java Malware Analysis -- Technical Readme

## Overview

This document describes the analysis of a **multi‑stage, in‑memory Java
stealer** that uses **JNI/JNA-backed native code**, blockchain-based
endpoint obfuscation, and legitimate Java/Kotlin libraries to evade
antivirus and endpoint detection systems.

This writeup is **defensive and analytical only**.

------------------------------------------------------------------------

## High-Level Architecture

Stages:

1.  Blockchain-based endpoint indirection\
2.  Java loader (stage 1 stub)\
3.  In-memory module JAR\
4.  JNI native loader initialization\
5.  Kotlin orchestration layer\
6.  Data collection handlers\
7.  Native execution via JNI/JNA\
8.  Data staging and exfiltration

------------------------------------------------------------------------

## Stage 0 -- Blockchain Endpoint Obfuscation

The malware does not hardcode its command-and-control endpoint. Instead,
it retrieves an encoded URL from **on-chain data** using JSON-RPC calls.

**Benefits:** - Avoids static string detection - Infrastructure is
difficult to takedown - Blockchain traffic is rarely blocked - Endpoint
can be changed without redeploying malware

The decoded result yields a base URL used to fetch the second-stage
payload.

------------------------------------------------------------------------

## Stage 1 -- Java Loader (Initial Stub)

The first executable component acts only as a loader.

**Responsibilities:** - Resolve obfuscated endpoint - Download
second-stage JAR - Load JAR directly into memory - Define classes using
a custom ClassLoader - Invoke a nonstandard entrypoint reflectively

There is **no main() method** and no payload is written to disk.

------------------------------------------------------------------------

## Stage 2 -- In-Memory Module JAR

The downloaded JAR contains most malware logic but still has **no
traditional entrypoint**.

Execution begins via a native-backed initializer:

    public static native void initializeWeedhack(String config);

This method is invoked immediately after class definition in memory.

------------------------------------------------------------------------

## Stage 3 -- Native Loader Initialization (JNI)

Most classes contain static initializers like:

    static {
        JNICLoader.init();
        ClassName.$jnicLoader();
    }

This forces native code execution as soon as the class is referenced,
hiding logic from Java decompilers.

------------------------------------------------------------------------

## Stage 4 -- Kotlin Orchestration Layer

The presence of the Kotlin standard library indicates that high-level
execution flow is written in Kotlin.

**Advantages:** - Coroutine-based concurrency - Complex
compiler-generated bytecode - Poor Java decompilation results - Harder
control-flow analysis

This layer determines execution order and conditions.

------------------------------------------------------------------------

## Stage 5 -- Data Collection Handlers

### Discord Handler

-   Desktop and browser Discord tokens
-   Encrypted and plaintext token handling
-   Native DPAPI decryption
-   Token metadata enrichment

### Browser & File Handlers

-   Browser credentials
-   Cookies and autofill data
-   Configuration files
-   Arbitrary file scraping

Actual logic resides in native code, not Java.

------------------------------------------------------------------------

## Stage 6 -- Native Execution (JNI + JNA)

### JNI

Used for: - Cryptography - String obfuscation - Anti-analysis checks -
Memory-only execution

### JNA

Used to access Windows APIs: - DPAPI - Registry - File system - Process
enumeration

This avoids suspicious Java implementations.

------------------------------------------------------------------------

## Stage 7 -- Data Staging & Exfiltration

Uses legitimate libraries: - OkHttp - Okio

**Benefits:** - Low detection rates - TLS-encrypted traffic - Chunked
binary uploads - Traffic resembles normal telemetry

------------------------------------------------------------------------

## Antivirus & EDR Evasion Summary

-   In-memory execution
-   No disk payload
-   No Java entrypoint
-   Native logic hidden
-   Blockchain-based indirection
-   Kotlin complexity
-   Legitimate libraries only

------------------------------------------------------------------------

## Conclusion

This malware demonstrates a **stealth-focused, modular stealer
architecture**. Java acts as a loader and coordinator, while all
sensitive operations occur in native code. The design intentionally
defeats both signature-based and behavior-based detection systems.

------------------------------------------------------------------------

## Disclaimer

This document is for **educational and defensive analysis only**.
